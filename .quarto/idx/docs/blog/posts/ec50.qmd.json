{"title":"Fungicide sensibility","markdown":{"yaml":{"title":"Fungicide sensibility","description":"How to estimate ec50 no R","author":"Kaique Alves","date":"5/08/2022","categories":["plant pathology","code","analysis"]},"headingText":"Carregar os pacotes","containsRefs":false,"markdown":"\n\nOlá pessoal!\n\nNesse post eu vou mostrar como estimar a $EC_{50}$ de fungicidas utilizando o `R`. Para aqueles que não sabem, a $EC_{50}$ é a concentração na qual um composto inibe 50% do crescimento de um organismo quando comparado com a testemunha (não tratado). \n\nNa Fitopatologia, a $EC_{50}$ é muito utilizada para avaliar a sensibilidade de fungos a fungicidas. O aumento na $EC_{50}$ de alguns isolados pode indicar a seleção para populações menos sensíveis. \n\n\n\nSegue abaixo os pacotes que vamos utilizar. O pacote utilizado para estimar a $EC_{50}$ é o `drc`. Caso você não tenha ele instalado, basta você ir no seu Console, colar `install.packages(\"drc\")` e apertar enter que ele será instalado. Caso não tenha os outros pacotes, faça o mesmo para eles, apenas troque o nome dentro do parênteses.\n\nApós ter instalado todos esses pacotes, basta carrega-los da seguinte forma:\n\n```{r message=FALSE, warning=FALSE}\nlibrary(tidyverse)\nlibrary(drc)\nlibrary(cowplot)\nlibrary(ggridges)\n```\n\n# Dados\n\nPrimeiramente, precisamos criar um banco de dados para podermos estimar a $EC_{50}$ a partir deles. Para isso, vou utilizar um modelo base para o comportamento de resposta a doses de fungicidas (Noel et al. 2018). Caso você já possua um banco de dados, basta carregar utilizando a função para tal (Veja o [post](https://kaiquealves.netlify.app/post/carregar_dados/carregar_dados/) sobre como carregar dados no R).\n\n\n\n\n $$ f(x) = c +\\frac{d-c}{1+exp(b(log(x)-log(e)))}$$\n\nEsse modelo é denominado de Log-logístico de quatro parâmetros `LL.4()`. Ele possui 4 parâmetros que são `b`, `c`, `d`, `e`. O parâmetro `b` é slope da curva no seu ponto de inflexão, `c` é a assíntota inferior da curva, `d` é o limite superior da curva, e `e` é a $EC_{50}$. A variável `x` no modelo significa a dose ou concentração do fungicida. Sendo assim, para cada valor de dose, é possível calcular um valor de crescimento micelial, por exemplo. \n\nPortanto, usando esse modelo e criei uma função para poder gerar valores de crescimento micelial. \n\n```{r}\ngrow = function(dose, b,c,d,e){\n  x = dose\n  y = c + (d-c)/(1+exp(b*(log(x)-log(e))))\n  erro = (y * 0.02 * ( (d + 0.05 * d) - y ))\n \n  \n  growth = rnorm(length(x),y, erro)\n  return(growth)\n}\n\n```\n\nAbaixo eu mostro um exemplo da utilização dessa função. Eu crio um vetor de doses no qual eu denominei de `doses`. Insiro o vetor da função que criei acima junto com alguns valores que atribui arbitrariamente para os parâmetros. \n\n```{r}\n#criar vetor de dose\ndoses = rep(c(0, 1e-6,1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1),5)\nset.seed(1) # Isso aqui faz que os valores simulados sejam sempre os mesmos.\n\n#simular crescimento micelial\ngrowth = grow(doses, b = 1, c = 0, d = 20, e = 0.001)\n\ndf1 = data.frame(doses,growth)\nhead(df1)\n```\n\nDepois disso eu gero um gráfico com os valores simulados.\n\n```{r}\ndf1 %>% \n  ggplot()+\n  geom_jitter(aes(factor(doses),growth, color = growth),\n              width = 0.05,\n              size = 3.5, \n              # color= \"steelblue\",\n              alpha = 1)+\n  geom_boxplot(aes(factor(doses),growth), fill = NA, size = .7)+\n  scale_color_viridis_c(option = \"D\",direction = 1)+\n  labs(x =\"Doses\", y = \"Crescimento Micelial\")+\n  theme_minimal_hgrid(font_size = 12)+\n  theme(legend.position = \"none\")\n\n```\n\n# Estimando a $EC_{50}$ para um isolado\n\nPara estimar a $EC_{50}$,  antes devemos selecionar o modelo que melhor se ajusta aos dados. Para isso vamos usar a função `drm()` do pacote `drc`. Nessa função precisamos fornecer a formula, que é uma descrição simbólica da equação, que basicamente vai indicar qual é sua coluna com os valores de doses e qual é a coluna que contem os valores de crescimento micelial. No nosso caso a formula será `growth~dose`. Também precisamos indicar qual é o `data.frame` no argumento `data`, no nosso caso `data = df1`. O argumento `fct` é onde você indica qual modelo será utilizado. No nosso caso, vamos utilizar o `LL.4()`. Para saber quais modelos estão disponíveis use a função `getMeanFunctions()`. \n\nveja a implementação do modelo. Aqui usamos a função summary para ver as estimativas dos parâmetros e suas estatísticas. \n\n```{r}\nmodel1 = drm(formula = growth~doses,  data = df1, fct = LL.4())\nsummary(model1)\n```\n\nVeja o gráfico do ajuste\n\n```{r}\nplot(model1)\n```\n\n\nPara obter o valor de $EC_{50}$ vamos usar a função `ED`. Nela você precisa indicar o modelo ajustado `model1`. No argumento `respLev` é onde você indica qual o valor de EC que quer estimar. Como queremos 50% (EC50), `respLev=50`. Além disso, no argumento `interval` você também pode indicar se deseja estimar os intervalos de confiança da estimativa media de $EC_{50}$. PAra isso, basta indicar qual tipo de intervalo você deseja Para o modelo `LL.4()` usando `interval= \"delta\"`.(Nota: Para mais informações sobre intervalos de confiança use `?ED`).\n\n```{r}\nED(model1, respLev=50, interval = \"delta\")\n```\n\n# Estimando a $EC_{50}$ para MAIS DE UM isolado\n\nÓtimo, conseguimos estimar a $EC_{50}$ para um isolado. No entanto, muitas vezes vamos precisar estimar para vários isolados. Sendo assim, agora vamos ver como a gente faz para estimar a $EC_{50}$ para uma situação onde temos 100 isolados.\n\nPara isso, vou criar um cenário no qual eu tenho 50 isolados de um fungo hipotético em que metade deles foram coletados em uma lavoura orgânica e a outra metade em uma lavoura convencional. Esses isolados foram submetidos a dois fungicidas diferentes, os quais denominei de `Fungicida A` e `Fungicida B`. \n\nAgora vamos criar um `dada.frame` para um `fungicida A` e um para o `fungicida B`.\n\n## Fungicida A\n\nPara o `fungicida A` eu considerei que os isolados do cultivo convencional seriam menos sensíveis a ele.\n\n```{r}\nset.seed(1)\nn_isolates = 25\n\nnrep = 5\nn_dose =7\nn_field = 2\nn = n_isolates*nrep*n_dose*n_field\nfield = c(rep(\"Organic\",nrep*n_dose), rep(\"Conventional\",nrep*n_dose))\nisolate = sort(rep(1:((n_isolates*2)),nrep*n_dose))\ndoses = (rep(c(0,1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1),nrep*n_field))\nEC50 = c(5e-3, 1e-1)# diferentes valores de Ec50\n\n\nfungicida_A = data.frame(isolate,\n           field = rep(field,n_isolates),\n           fungicida = \"Fungicide A\",\n           dose = rep(doses,n_isolates)) %>% \n  mutate(efeito = case_when(\n    field == \"Conventional\" ~ rnorm(n,EC50[2],0.0001),\n    field == \"Organic\" ~ rnorm(n,EC50[1],0.0001))) %>% \n  mutate(growth = grow(dose, b = 1, c = 0, d = 20, e = efeito))%>% \n  dplyr::select(-efeito)\n\nhead(fungicida_A)\n\n```\n\n\n## Fungicida B\nJá Para o `fungicida B` eu considerei que os isolados teriam o mesmo padrão de sensibilidade, ou seja, não existe diferença entre as $EC_{50}$.\n\n\n```{r}\nset.seed(1)\nn_isolates = 25\nnrep = 5\nn_dose =7\nn_field = 2\nn = n_isolates*nrep*n_dose*n_field\nfield = c(rep(\"Organic\",nrep*n_dose), rep(\"Conventional\",nrep*n_dose))\nisolate = sort(rep(1:((n_isolates*2)),nrep*n_dose))\ndoses = (rep(c(0,1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1),nrep*n_field))\nEC50 = c(5e-3, 5e-3) # Mesma Ec50\n\n\nfungicida_B = data.frame(isolate,\n                        field = rep(field,n_isolates),\n                        fungicida = \"Fungicide B\",\n                        dose = rep(doses,n_isolates)) %>% \n  mutate(efeito = case_when(\n    field == \"Conventional\" ~ rnorm(n,EC50[2],0.0001),\n    field == \"Organic\" ~ rnorm(n,EC50[1],0.0001))) %>% \n  mutate(growth = grow(dose, b = 1, c = 0, d = 20, e = efeito)) %>% \n  dplyr::select(-efeito)\n\nhead(fungicida_B)\n```\n\nAqui eu uso a função `bind_rows` para juntar os dois `data.frames` criados acima e crio um novo `data.frame` chamado apenas de `fungicida`.\n\n```{r message=FALSE, warning=FALSE}\nfungicida = fungicida_A %>% \n  bind_rows(fungicida_B)\nhead(fungicida)\n```\n\nExiste uma forma em que você pode indicar na função `drm()` que você tem mais de um isolado no seu banco de dados. O código ficaria algo como abaixo. No entanto, se você tem muitos isolados a função pode demorar muito para rodar (se rodar). Além disso, o output da função não é muito fácil de lidar caso você não tenha muita experiência em lidar com matrizes no R.\n\n```{r eval=FALSE, include=T}\n# NÂO RODE ISSO\nmodel = drm(growth~dose, curveid = isolate,  fct = LL.4(), data = fungicida)\nED(model, 50, interval = \"delta\")\n```\n\n\n```{r eval=FALSE, include=FALSE}\nfct = LL.4()\n\ndata = fungicida\nisolate_col = \"isolate\"\nstrata_col = c(\"field\", \"fungicida\")\nbox = data.frame()\nstrata_col=NULL\n\nif(is.null(strata_col)){\n  data_uni=data %>% \n    mutate(strata = \"\")\n  strata_col= \"strata\"\n}else{\ndata_uni = data %>% \n  unite(strata, strata_col, sep = \"---\")\n}\nSTRATA = data_uni[[\"strata\"]]\nstrata = as.character(unique(STRATA))\n\n\nfor(i in 1:length(strata)){\n\nrowi = data_uni[[\"strata\"]]==strata[i]\ndatai = data_uni[rowi,]\n\n\nID = datai[[isolate_col]]\nid = as.character(unique(ID))\n\nfor(k in 1:length(id)){\nrowk = datai[[isolate_col]]==id[k]\ndatak = datai[rowk,]\n\n\ntry({\nmodel = drm(growth~dose,  fct =fct , data = datak)\ned = ED(model, 50, interval = \"delta\", display = F)\nlil_box = data.frame(ID = as.character(id[k]), strata = as.character(strata[i]) ,ed) %>% \n  remove_rownames() %>% \n  mutate(strata = as.character(strata),\n         ID = as.character(ID)) %>% \n  separate(strata, into = strata_col, sep = \"---\")\nbox = box %>% \n  bind_rows(lil_box)\n\n},silent = T)\n\n\n}}\nbox\n\n```\n\n\n\n```{r eval=FALSE, include=FALSE}\nestimate_EC50 = function(formula, data, isolate_col, strata_col = NULL, fct,\n                         interval = c(\"none\", \"delta\", \"fls\", \"tfls\")){\n\nbox = data.frame()\n\nif(is.null(strata_col)){\n  data_uni=data %>% \n    mutate(strata = \"\")\n  strata_col= \"strata\"\n}else{\ndata_uni = data %>% \n  unite(strata, strata_col, sep = \"---\")\n}\n\nSTRATA = data_uni[[\"strata\"]]\nstrata = as.character(unique(STRATA))\n\n\nfor(i in 1:length(strata)){\n\nrowi = data_uni[[\"strata\"]]==strata[i]\ndatai = data_uni[rowi,]\n\n\nID = datai[[isolate_col]]\nid = as.character(unique(ID))\n\nfor(k in 1:length(id)){\nrowk = datai[[isolate_col]]==id[k]\ndatak = datai[rowk,]\n\n\ntry({\nmodel = drm(formula,  fct =fct , data = datak)\ned = ED(model, 50, interval = interval, display = F)\nlil_box = data.frame(ID = as.character(id[k]), strata = as.character(strata[i]) ,ed) %>% \n  remove_rownames() %>% \n  mutate(strata = as.character(strata),\n         ID = as.character(ID)) %>% \n  separate(strata, into = strata_col,sep = \"---\")\nbox = box %>% \n  bind_rows(lil_box)\n\n},silent = T)\n\n\n}}\nbox\n}\n```\n\n\nSendo assim, eu criei um pacote para facilitar nossa vida.\n\nO nome do pacote é `ec50estimator`. Para instalar esse pacote você vai precisar usar a função `install.packages()`: \n\n```{r eval=FALSE, include=T}\ninstall.packages(\"ec50estimator\")\n```\n\nA versão de desenvolvimento pode ser instalada usando o seguinte código:\n\n```{r eval=FALSE, include=T}\nif (!require(devtools)) {\n  install.packages(\"devtools\")\n}\n\ndevtools::install_github(\"AlvesKS/ec50estimator\")'\n```\n\nVeja mais informaçãoes sobre o pacote [aqui](https://alvesks.github.io/ec50estimator/){target=\"_blank\"}\n\nO processo de instalação pode sugerir a atualização/instalação de alguns pacote, portanto recomendo que faça a instalação desses outros pacotes.\n\nAssim que instalar o pacote. O próximo passo é carrega-lo no seu script.\n\n```{r}\nlibrary(ec50estimator)\n```\n\nA função `estimate_EC50()` é usada para calcular as EC50 para cada isolado dentro de cada sistema de cultivo e para cada fungicida. Assim como na função `drm()`, na `estimate_EC50()` você também precisa fornecer a `formula`. Forneça também no argumento `data` o `data.frame` onde estão seus dados. Indique a coluna que identifica cada isolado no argumento `isolate_col`. Se seus dados são estratificados (por região, sistema de cultivo ou ano, por exemplo) indique as colunas no argumento `strata_col`. Indique o modelo será utilizado no argumento `fct` (mesmos do pacote `drc`). Se você quer que os intervalos de confiança sejam estimados, indique no argumento `interval` (funciona da mesma forma que a função `drm()`). \n\n\n```{r}\ndf_ec50 = estimate_EC50(growth~dose,\n                        data =fungicida,\n                        isolate_col = \"isolate\", \n                        strata_col =  c(\"field\",\"fungicida\"),\n                        interval = \"delta\",\n                        fct = LL.3())\nhead(df_ec50)\n```\n\n\n:::{.callout-warning} \nATENÇÃO: Neste post, eu usei o mesmo modelo (`LL.4()`) para os dois fungicidas (A e B). No entanto, é importante verificar qual modelo é mais apropriado para seus dados. Para isso, antes de rodar a função `estimate_EC50()` para todos seus dados, use a função `drm()` para ajustar um modelo para alguns isolados e posteriormente utilize a função `mselect()` para calcular as estatísticas que vão te auxiliar a selecionar o melhor modelo. Dica: quanto menor o valor de AIC, melhor o modelo. Mais informações rode o comando `?mselect` no seu Console.\n:::\n\n## Gráficos\n\nVeja as estimativas de EC50 e intervalos de confiança para todos os isolados.\n\n```{r fig.height=10, fig.width=5}\ndf_ec50 %>% \n  ggplot(aes(as.numeric(ID),Estimate, color = field))+\n  geom_point(size = 2)+\n  geom_errorbar(aes(ymin=Lower,ymax = Upper), width=0)+\n  facet_wrap(~fungicida, scales = \"free_x\",nrow = 1)+\n  scale_y_log10()+\n  scale_x_continuous(breaks = 1:50)+\n  scale_color_manual(values = c(\"darkred\", \"steelblue\"))+\n  labs(x = \"Isolates\", y = \"EC50\")+\n  theme_minimal_vgrid(font_size = 10)+\n  coord_flip()+\n  theme(axis.text.x = element_text(size=10),\n        legend.position = \"bottom\")\n```\n\n\nUse o pacote `ggridges` para criar gráficos de densidade.\n\n```{r fig.height=5, fig.width=6}\ndf_ec50 %>% \n  ggplot(aes(Estimate, field, fill = stat(x)))+\n  geom_density_ridges_gradient(alpha = 0.3)+\n  scale_x_log10()+\n  scale_fill_viridis_c(option = \"C\")+\n  facet_wrap(~fungicida, nrow = 2)+\n  theme_minimal_hgrid()+\n  labs(x = \"EC50\", y = \"Field\")+\n  theme(legend.position = \"none\")\n```\n\n\n\n# References\n\nNoel, Z. A., Wang, J., and Chilvers, M. I. 2018. Significant Influence of EC 50 Estimation by Model Choice and EC 50 Type. Plant Disease. 102:708–714.\n\n\n\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"ec50.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"0.9.370","editor":"visual","theme":{"light":"flatly","dark":"darkly"},"title":"Fungicide sensibility","description":"How to estimate ec50 no R","author":"Kaique Alves","date":"5/08/2022","categories":["plant pathology","code","analysis"]},"extensions":{"book":{"multiFile":true}}}}}